<?php
/**
 * Author: Ted Bowman
 * Date: 8/23/15
 * Time: 11:45 AM
 */

namespace Drupal\block_visibility_groups\Plugin\Condition;


use Drupal\Core\Plugin\ContextAwarePluginInterface;
use Drupal\Component\Plugin\Exception\ContextException;
use Drupal\Core\Condition\ConditionAccessResolverTrait;
use Drupal\Core\Condition\ConditionPluginBase;
use Drupal\Core\Entity\EntityStorageInterface;
use Drupal\Core\Executable\ExecutableManagerInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
use Drupal\Core\Plugin\Context\ContextHandlerInterface;
use Drupal\Core\Plugin\Context\ContextRepositoryInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\block_visibility_groups\Entity\BlockVisibilityGroup;
use Drupal\Core\Condition\ConditionPluginCollection;
use Symfony\Component\HttpFoundation\Request;

/**
 * Provides a 'Condition Group' condition.
 *
 * @Condition(
 *   id = "condition_group",
 *   label = @Translation("Condition Group"),
 * )
 */
class ConditionGroup extends ConditionPluginBase implements ContainerFactoryPluginInterface{

  use ConditionAccessResolverTrait;
  /**
   * The condition plugin manager.
   *
   * @var \Drupal\Core\Executable\ExecutableManagerInterface
   */
  protected $manager;

  /**
   * The plugin context handler.
   *
   * @var \Drupal\Core\Plugin\Context\ContextHandlerInterface
   */
  protected $contextHandler;

  /**
   * The context manager service.
   *
   * @var \Drupal\Core\Plugin\Context\ContextRepositoryInterface
   */
  protected $contextRepository;

  /**
   * The entity storage.
   *
   * @var \Drupal\Core\Entity\EntityStorageInterface
   */
  protected $entityStorage;

  /**
   * The current Request object.
   *
   * @var \Symfony\Component\HttpFoundation\Request
   */
  protected $request;

  /**
   * Evaluates the condition and returns TRUE or FALSE accordingly.
   *
   * @return bool
   *   TRUE if the condition has been met, FALSE otherwise.
   */
  public function evaluate() {
    $block_visibility_group_id = $this->configuration['block_visibility_group'];
    if (empty($block_visibility_group_id )) {
      return TRUE;
    }
    /** @var BlockVisibilityGroup $block_visibility_group */
    $block_visibility_group = $this->entityStorage->load($block_visibility_group_id);
    /** @var ConditionPluginCollection $conditions */
    $conditions = $block_visibility_group->getConditions();
    if ($this->applyContexts($conditions)) {
      return $this->resolveConditions($conditions, $block_visibility_group->getLogic());
    }
    return FALSE;
  }

  protected function applyContexts(ConditionPluginCollection &$conditions) {
    foreach ($conditions as $condition) {
      if ($condition instanceof ContextAwarePluginInterface) {
        try {
          $contexts = $this->contextRepository->getRuntimeContexts(array_values($condition->getContextMapping()));
          $this->contextHandler->applyContextMapping($condition, $contexts);
        }
        catch (ContextException $e) {
          return FALSE;
        }
      }
    }
    return TRUE;
  }

  /**
   * Provides a human readable summary of the condition's configuration.
   */
  public function summary() {
    // TODO: Implement summary() method.
  }

  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
    $block_visibility_groups = $this->entityStorage->loadMultiple();
    $options = ['' => $this->t('No Block Visibility Group')];
    foreach ($block_visibility_groups as $type) {
      $options[$type->id()] = $type->label();
    }

    $form['block_visibility_group'] = array(
      '#title' => $this->t('Block Visibility Groups'),
      '#type' => 'select',
      '#options' => $options,
      //'#default_value' => $default,
    );
    $default = isset($this->configuration['block_visibility_group']) ? $this->configuration['block_visibility_group'] : '';

    if (!$default) {
      $default = $this->request->query->get('block_visibility_group');
      if ($default) {
        $form['block_visibility_group']['#disabled'] = TRUE;
        $form_state->setTemporaryValue('block_visibility_group_query', $default);
      }
    }
    $form['block_visibility_group']['#default_value'] = $default;
    $form = parent::buildConfigurationForm($form, $form_state); // TODO: Change the autogenerated stub
    $form['negate']['#access'] = FALSE;
    return $form;
  }


  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
    $user_values = $form_state->getValues();
    foreach ($user_values as $key => $value) {
      if ($key != 'negate') {
        $this->configuration[$key] = $value;
      }
    }
    parent::submitConfigurationForm($form, $form_state);
  }

  /**
   * Creates an instance of the plugin.
   *
   * @param \Symfony\Component\DependencyInjection\ContainerInterface $container
   *   The container to pull out services used in the plugin.
   * @param array $configuration
   *   A configuration array containing information about the plugin instance.
   * @param string $plugin_id
   *   The plugin ID for the plugin instance.
   * @param mixed $plugin_definition
   *   The plugin implementation definition.
   *
   * @return static
   *   Returns an instance of this plugin.
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $container->get('entity.manager')->getStorage('block_visibility_group'),
      $container->get('plugin.manager.condition'),
      $container->get('context.handler'),
      $container->get('context.repository'),
      $container->get('request_stack')->getCurrentRequest(),
      $configuration,
      $plugin_id,
      $plugin_definition);
  }

  public function __construct(EntityStorageInterface $entity_storage, ExecutableManagerInterface $manager, ContextHandlerInterface $context_handler, ContextRepositoryInterface $context_repository, Request $request, array $configuration, $plugin_id, $plugin_definition) {
    parent::__construct($configuration, $plugin_id, $plugin_definition); // TODO: Change the autogenerated stub
    $this->manager = $manager;
    $this->contextHandler = $context_handler;
    $this->contextRepository = $context_repository;
    $this->entityStorage = $entity_storage;
    $this->request = $request;
  }

}
